<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>三维交互式图形展示 - 3D Interactive Graphics</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Microsoft YaHei', 'SimHei', sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: #00ff88;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #00ff88;
            font-size: 14px;
            z-index: 100;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
        }
        
        #info-panel h1 {
            font-size: 24px;
            margin-bottom: 15px;
            text-shadow: 0 0 10px #00ff88;
        }
        
        #info-panel p {
            margin: 8px 0;
            line-height: 1.6;
        }
        
        .coordinate {
            color: #ff6b6b;
            font-weight: bold;
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 30px;
            border-radius: 50px;
            border: 2px solid #00d4ff;
            color: #00d4ff;
            font-size: 12px;
            z-index: 100;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 30px rgba(0, 212, 255, 0.4);
        }
        
        #fps-counter {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: #ffaa00;
            padding: 10px 20px;
            border-radius: 5px;
            border: 2px solid #ffaa00;
            font-size: 16px;
            font-weight: bold;
            z-index: 100;
            backdrop-filter: blur(10px);
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="info-panel">
        <h1>🌌 三维空间交互系统</h1>
        <p>📍 鼠标位置: <span class="coordinate" id="mouse-x">0</span>, <span class="coordinate" id="mouse-y">0</span></p>
        <p>🎯 相机角度: <span id="camera-angle">0°</span></p>
        <p>🔄 旋转速度: <span id="rotation-speed">1.0x</span></p>
        <p>✨ 粒子数量: <span id="particle-count">5000</span></p>
        <p>🎨 活跃对象: <span id="active-objects">12</span></p>
    </div>
    
    <div id="controls">
        💡 移动鼠标控制相机 | 🖱️ 点击改变颜色 | ⚡ 滚轮缩放视图
    </div>
    
    <div id="fps-counter">
        FPS: <span id="fps">60</span>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // 初始化场景、相机和渲染器
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x0a0a0a, 0.002);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 50;
        
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        
        // 鼠标位置追踪
        let mouseX = 0;
        let mouseY = 0;
        let targetX = 0;
        let targetY = 0;
        
        // 创建复杂的几何体组
        const geometryGroup = new THREE.Group();
        
        // 中心主体 - 复杂的多面体
        const icosahedronGeometry = new THREE.IcosahedronGeometry(8, 1);
        const icosahedronMaterial = new THREE.MeshPhongMaterial({
            color: 0x00ff88,
            wireframe: false,
            emissive: 0x00ff88,
            emissiveIntensity: 0.2,
            shininess: 100
        });
        const icosahedron = new THREE.Mesh(icosahedronGeometry, icosahedronMaterial);
        icosahedron.castShadow = true;
        geometryGroup.add(icosahedron);
        
        // 环绕的立方体
        const cubes = [];
        for (let i = 0; i < 8; i++) {
            const cubeGeometry = new THREE.BoxGeometry(3, 3, 3);
            const cubeMaterial = new THREE.MeshPhongMaterial({
                color: Math.random() * 0xffffff,
                emissive: Math.random() * 0x444444,
                shininess: 80
            });
            const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
            
            const angle = (i / 8) * Math.PI * 2;
            cube.position.x = Math.cos(angle) * 20;
            cube.position.y = Math.sin(angle) * 20;
            cube.position.z = Math.sin(angle * 2) * 10;
            
            cube.castShadow = true;
            cube.receiveShadow = true;
            cubes.push(cube);
            geometryGroup.add(cube);
        }
        
        // 环形结构
        const torusGeometry = new THREE.TorusGeometry(15, 2, 16, 100);
        const torusMaterial = new THREE.MeshPhongMaterial({
            color: 0xff6b6b,
            wireframe: true,
            emissive: 0xff6b6b,
            emissiveIntensity: 0.3
        });
        const torus = new THREE.Mesh(torusGeometry, torusMaterial);
        torus.rotation.x = Math.PI / 4;
        geometryGroup.add(torus);
        
        // 第二个环形
        const torus2 = new THREE.Mesh(
            new THREE.TorusGeometry(18, 1.5, 16, 100),
            new THREE.MeshPhongMaterial({
                color: 0x00d4ff,
                wireframe: true,
                emissive: 0x00d4ff,
                emissiveIntensity: 0.3
            })
        );
        torus2.rotation.y = Math.PI / 3;
        geometryGroup.add(torus2);
        
        scene.add(geometryGroup);
        
        // 粒子系统
        const particleCount = 5000;
        const particlesGeometry = new THREE.BufferGeometry();
        const particlePositions = new Float32Array(particleCount * 3);
        const particleColors = new Float32Array(particleCount * 3);
        const particleVelocities = [];
        
        for (let i = 0; i < particleCount; i++) {
            particlePositions[i * 3] = (Math.random() - 0.5) * 200;
            particlePositions[i * 3 + 1] = (Math.random() - 0.5) * 200;
            particlePositions[i * 3 + 2] = (Math.random() - 0.5) * 200;
            
            const color = new THREE.Color();
            color.setHSL(Math.random(), 1.0, 0.5);
            particleColors[i * 3] = color.r;
            particleColors[i * 3 + 1] = color.g;
            particleColors[i * 3 + 2] = color.b;
            
            particleVelocities.push({
                x: (Math.random() - 0.5) * 0.1,
                y: (Math.random() - 0.5) * 0.1,
                z: (Math.random() - 0.5) * 0.1
            });
        }
        
        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
        particlesGeometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));
        
        const particlesMaterial = new THREE.PointsMaterial({
            size: 0.5,
            vertexColors: true,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending
        });
        
        const particleSystem = new THREE.Points(particlesGeometry, particlesMaterial);
        scene.add(particleSystem);
        
        // 光照系统
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);
        
        const pointLight1 = new THREE.PointLight(0x00ff88, 2, 100);
        pointLight1.position.set(20, 20, 20);
        pointLight1.castShadow = true;
        scene.add(pointLight1);
        
        const pointLight2 = new THREE.PointLight(0xff6b6b, 2, 100);
        pointLight2.position.set(-20, -20, 20);
        pointLight2.castShadow = true;
        scene.add(pointLight2);
        
        const pointLight3 = new THREE.PointLight(0x00d4ff, 2, 100);
        pointLight3.position.set(0, 20, -20);
        scene.add(pointLight3);
        
        // 动态光源
        const movingLight = new THREE.PointLight(0xffaa00, 3, 50);
        scene.add(movingLight);
        
        // 鼠标事件监听
        document.addEventListener('mousemove', (event) => {
            mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
            
            document.getElementById('mouse-x').textContent = event.clientX;
            document.getElementById('mouse-y').textContent = event.clientY;
        });
        
        // 点击改变颜色
        document.addEventListener('click', () => {
            icosahedronMaterial.color.setHex(Math.random() * 0xffffff);
            icosahedronMaterial.emissive.setHex(Math.random() * 0x444444);
            
            cubes.forEach(cube => {
                cube.material.color.setHex(Math.random() * 0xffffff);
            });
        });
        
        // 滚轮缩放
        document.addEventListener('wheel', (event) => {
            camera.position.z += event.deltaY * 0.05;
            camera.position.z = Math.max(20, Math.min(100, camera.position.z));
        });
        
        // 窗口大小调整
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // FPS 计数器
        let lastTime = performance.now();
        let frames = 0;
        
        // 动画循环
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;
            
            // 平滑相机移动
            targetX = mouseX * 30;
            targetY = mouseY * 30;
            camera.position.x += (targetX - camera.position.x) * 0.05;
            camera.position.y += (targetY - camera.position.y) * 0.05;
            camera.lookAt(scene.position);
            
            // 旋转主几何体组
            geometryGroup.rotation.x += 0.002;
            geometryGroup.rotation.y += 0.003;
            
            // 旋转中心多面体
            icosahedron.rotation.x += 0.01;
            icosahedron.rotation.y += 0.01;
            
            // 动画立方体
            cubes.forEach((cube, i) => {
                const angle = (i / 8) * Math.PI * 2 + time;
                cube.position.x = Math.cos(angle) * 20;
                cube.position.y = Math.sin(angle) * 20;
                cube.position.z = Math.sin(angle * 2) * 10;
                
                cube.rotation.x += 0.02;
                cube.rotation.y += 0.02;
                
                // 根据鼠标位置缩放
                const scale = 1 + Math.sin(time * 2 + i) * 0.3;
                cube.scale.set(scale, scale, scale);
            });
            
            // 旋转环形
            torus.rotation.x += 0.005;
            torus.rotation.y += 0.003;
            torus2.rotation.y += 0.007;
            torus2.rotation.z += 0.002;
            
            // 更新粒子
            const positions = particlesGeometry.attributes.position.array;
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] += particleVelocities[i].x;
                positions[i * 3 + 1] += particleVelocities[i].y;
                positions[i * 3 + 2] += particleVelocities[i].z;
                
                // 边界检测
                if (Math.abs(positions[i * 3]) > 100) particleVelocities[i].x *= -1;
                if (Math.abs(positions[i * 3 + 1]) > 100) particleVelocities[i].y *= -1;
                if (Math.abs(positions[i * 3 + 2]) > 100) particleVelocities[i].z *= -1;
                
                // 受鼠标影响
                const dx = positions[i * 3] - targetX;
                const dy = positions[i * 3 + 1] - targetY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 30) {
                    positions[i * 3] += dx * 0.01;
                    positions[i * 3 + 1] += dy * 0.01;
                }
            }
            particlesGeometry.attributes.position.needsUpdate = true;
            
            // 旋转粒子系统
            particleSystem.rotation.y += 0.001;
            
            // 移动动态光源
            movingLight.position.x = Math.sin(time) * 30;
            movingLight.position.y = Math.cos(time * 1.5) * 30;
            movingLight.position.z = Math.sin(time * 0.7) * 30;
            
            // 更新信息面板
            const angle = Math.atan2(camera.position.y, camera.position.x) * (180 / Math.PI);
            document.getElementById('camera-angle').textContent = angle.toFixed(1) + '°';
            document.getElementById('rotation-speed').textContent = (1 + Math.abs(mouseX)).toFixed(2) + 'x';
            
            // FPS 计数
            frames++;
            const currentTime = performance.now();
            if (currentTime >= lastTime + 1000) {
                document.getElementById('fps').textContent = frames;
                frames = 0;
                lastTime = currentTime;
            }
            
            renderer.render(scene, camera);
        }
        
        animate();
    </script>
</body>
</html>
