```html
<!doctype html>
<html lang="zh">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>斐波那契 3D 螺旋</title>
<style>
html,body{height:100%;margin:0;background:#000;overflow:hidden;font-family:serif}
#c{width:100%;height:100%;display:block}
#hud{
  position:absolute;left:12px;top:12px;color:#9cffb3;font-size:16px;
  background:rgba(0,0,0,0.38);padding:10px;border-radius:8px;backdrop-filter:blur(4px);
  line-height:1.35;white-space:pre-wrap;
  pointer-events:none;
}
.eq{color:#ffd387;font-weight:700}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="hud" aria-hidden="true"><span class="eq" id="eq">加载中…</span></div>
<script>
/* 单文件实现：WebGL 点云呈现菲波那契螺旋，鼠标控制相机，移动时显示中文数学公式（x,y 轴调整） */
/* 极简 WebGL helper + 粒子系统，所有资源内联，无外部依赖。*/

/* ---------- GL 初始 ---------- */
const canvas=document.getElementById('c');
const gl=canvas.getContext('webgl',{antialias:true})||canvas.getContext('experimental-webgl');
if(!gl){ alert('无法初始化 WebGL'); throw 0; }
function resize(){
  const dpr=Math.min(window.devicePixelRatio||1,2);
  const w=Math.floor(innerWidth*dpr), h=Math.floor(innerHeight*dpr);
  if(canvas.width!==w||canvas.height!==h){ canvas.width=w; canvas.height=h; canvas.style.width=innerWidth+'px'; canvas.style.height=innerHeight+'px'; gl.viewport(0,0,w,h); }
}
addEventListener('resize',resize); resize();

/* ---------- 着色器 ---------- */
const vs=`attribute vec3 aPos;attribute float aSize;attribute vec3 aCol;uniform mat4 uPV;varying vec3 vCol;void main(){vCol=aCol;gl_Position=uPV*vec4(aPos,1.0);gl_PointSize=aSize;}`;
const fs=`precision mediump float;varying vec3 vCol;void main(){vec2 c=gl_PointCoord-0.5;float r=length(c);float a=smoothstep(0.5,0.45,r);gl_FragColor=vec4(vCol,a);}`;
function compile(gl,type,src){const s=gl.createShader(type);gl.shaderSource(s,src);gl.compileShader(s);if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)){console.error(gl.getShaderInfoLog(s));}return s;}
function link(gl,vsSrc,fsSrc){const v=compile(gl,gl.VERTEX_SHADER,vsSrc);const f=compile(gl,gl.FRAGMENT_SHADER,fsSrc);const p=gl.createProgram();gl.attachShader(p,v);gl.attachShader(p,f);gl.linkProgram(p);if(!gl.getProgramParameter(p,gl.LINK_STATUS))console.error(gl.getProgramInfoLog(p));return p;}
const prog=link(gl,vs,fs);gl.useProgram(prog);
const aPos=gl.getAttribLocation(prog,'aPos');
const aSize=gl.getAttribLocation(prog,'aSize');
const aCol=gl.getAttribLocation(prog,'aCol');
const uPV=gl.getUniformLocation(prog,'uPV');

/* ---------- 数据生成：菲波那契螺旋 ---------- */
function genPoints(n){
  const positions=new Float32Array(n*3);
  const sizes=new Float32Array(n);
  const colors=new Float32Array(n*3);
  const goldenAngle=2.399963229728653;
  for(let i=0;i<n;i++){
    const t=i;
    const angle=t*goldenAngle + Math.sin(t*0.013)*0.6;
    const radius=Math.pow(t+1,0.52)*0.72;
    const x=Math.cos(angle)*radius;
    const y=Math.sin(angle)*radius;
    const z=(t - n/2)*0.2 + Math.sin(t*0.021)*2.0;
    positions[3*i]=x;
    positions[3*i+1]=y;
    positions[3*i+2]=z;
    sizes[i]=4.0 + (Math.sin(t*0.045)+1.0)*3.5;
    const r=0.5+0.5*Math.sin(t*0.02);
    const g=0.3+0.7*Math.sin(t*0.011+2.0);
    const b=0.4+0.6*Math.cos(t*0.017);
    colors[3*i]=r; colors[3*i+1]=g; colors[3*i+2]=b;
  }
  return {positions,sizes,colors};
}
const N=6000;
const {positions,sizes,colors}=genPoints(N);

/* ---------- 缓冲绑定 ---------- */
const posBuf=gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER,posBuf); gl.bufferData(gl.ARRAY_BUFFER,positions,gl.STATIC_DRAW);
const sizeBuf=gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER,sizeBuf); gl.bufferData(gl.ARRAY_BUFFER,sizes,gl.STATIC_DRAW);
const colBuf=gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER,colBuf); gl.bufferData(gl.ARRAY_BUFFER,colors,gl.STATIC_DRAW);

/* ---------- 相机与交互 ---------- */
let camZ=120; let rotX=0, rotY=0; let targetX=0, targetY=0;
const hudEq=document.getElementById('eq');
function updateEq(x,y){
  // 显示中文数学公式（LaTeX 风格字符展示为纯文本中文描述）
  // 动态公式依赖 x,y（摄像机目标）
  const fx = (x).toFixed(3);
  const fy = (y).toFixed(3);
  // 复杂数学表达式（中文）
  const s = "x' = x·cosθ - y·sinθ\ny' = x·sinθ + y·cosθ\nθ(x,y) = arctan\\left(\\frac{y}{x}\\right) + 0.5·e^{-(" + fx + "·x^2 + " + fy + "·y^2)}";
  hudEq.textContent = s;
}
canvas.addEventListener('mousemove', (e)=>{
  const r=canvas.getBoundingClientRect();
  const mx=(e.clientX - r.left)/r.width;
  const my=(e.clientY - r.top)/r.height;
  rotY = (mx-0.5)*Math.PI*1.2;
  rotX = (my-0.5)*Math.PI*0.7;
  targetX = (mx-0.5)*40;
  targetY = (0.5-my)*40;
  updateEq(targetX,targetY);
});
canvas.addEventListener('wheel', (e)=>{ e.preventDefault(); camZ += Math.sign(e.deltaY)*8; camZ = Math.max(20,Math.min(600,camZ)); }, {passive:false});

/* ---------- 矩阵工具（最小） ---------- */
function mat4_perspective(fov, aspect, near, far){
  const f = 1.0/Math.tan(fov/2);
  const nf = 1/(near - far);
  const out = new Float32Array(16);
  out[0]=f/aspect; out[1]=0; out[2]=0; out[3]=0;
  out[4]=0; out[5]=f; out[6]=0; out[7]=0;
  out[8]=0; out[9]=0; out[10]=(far+near)*nf; out[11]=-1;
  out[12]=0; out[13]=0; out[14]=(2*far*near)*nf; out[15]=0;
  return out;
}
function mat4_mul(a,b){
  const out=new Float32Array(16);
  for(let i=0;i<4;i++){
    for(let j=0;j<4;j++){
      let s=0;
      for(let k=0;k<4;k++) s+=a[k*4+j]*b[i*4+k];
      out[i*4+j]=s;
    }
  }
  return out;
}
function mat4_translate(tx,ty,tz){
  const m=new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, tx,ty,tz,1]);
  return m;
}
function mat4_rotateX(a){
  const c=Math.cos(a), s=Math.sin(a);
  return new Float32Array([1,0,0,0, 0,c,s,0, 0,-s,c,0, 0,0,0,1]);
}
function mat4_rotateY(a){
  const c=Math.cos(a), s=Math.sin(a);
  return new Float32Array([c,0,-s,0, 0,1,0,0, s,0,c,0, 0,0,0,1]);
}

/* ---------- 渲染循环 ---------- */
gl.enable(gl.BLEND); gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
gl.disable(gl.DEPTH_TEST);

function render(t){
  resize();
  gl.clearColor(0.02,0.02,0.02,1);
  gl.clear(gl.COLOR_BUFFER_BIT);

  // 视图投影矩阵
  const aspect = canvas.width / canvas.height;
  const proj = mat4_perspective(45*Math.PI/180, aspect, 0.1, 2000);
  // camera transform: translate back by camZ, then rotate by rotX/Y, then translate to target
  const tr = mat4_translate(-targetX, -targetY, -camZ);
  const ry = mat4_rotateY(rotY + Math.sin(t*0.0003)*0.02);
  const rx = mat4_rotateX(rotX + Math.cos(t*0.0002)*0.02);
  const view = mat4_mul(rx, ry);
  const pv = mat4_mul(proj, mat4_mul(view, tr));
  gl.uniformMatrix4fv(uPV,false,pv);

  // bind buffers & attributes
  gl.bindBuffer(gl.ARRAY_BUFFER,posBuf);
  gl.enableVertexAttribArray(aPos); gl.vertexAttribPointer(aPos,3,gl.FLOAT,false,0,0);
  gl.bindBuffer(gl.ARRAY_BUFFER,sizeBuf);
  gl.enableVertexAttribArray(aSize); gl.vertexAttribPointer(aSize,1,gl.FLOAT,false,0,0);
  gl.bindBuffer(gl.ARRAY_BUFFER,colBuf);
  gl.enableVertexAttribArray(aCol); gl.vertexAttribPointer(aCol,3,gl.FLOAT,false,0,0);

  gl.drawArrays(gl.POINTS,0,N);

  requestAnimationFrame(render);
}
updateEq(0,0);
requestAnimationFrame(render);
</script>
</body>
</html>
```
